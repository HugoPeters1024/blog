{% extends "templates/post.html" %}

{% set src = "https://github.com/HugoPeters1024/MonadsInCSharp/" %}
{% set Msrc = "https://github.com/HugoPeters1024/MonadsInCSharp/blob/master/MondadsInCsharp/SList.cs" %}
{% set Dsrc = "https://github.com/HugoPeters1024/MonadsInCSharp/blob/master/MondadsInCsharp/Demos/ListDemo.cs" %}

{% block favicon %}/posts/4/logo.png{% endblock %}

{% block post %}
<h2>Preface: the story continues</h2>
I will start of with a warning that this post is the continuation of
{{ macros.refPost(3) }}. That post explained numerous concepts of 
functional programming in great detail. Therefore I
will refrain from the same endeavour in this post, and assume you already have a
basic understanding of what a Functor, Applicative and a Monad is. The previous progress
is captured by the overarching repository of this larger endeavour to explore
functional concepts in C#: <a href="{{src}}" target="_blank">repo</a>. Naturally the
work of this post is also found there; as is denoted in the bottom right corner of relevant
code snippets.

<h2>The basic class structure</h2>
<p>
Functional languages are keen on representing their lists as singly linked lists.
This discourages the idea of accessing the list randomly since the lookup
operation now requires linear time as opposed to constant time. The only sensible
way of using such a list is by traversing it a from beginning to end.
</p>

<p>
An instance of such a list be one of two things: and empty list, containing
nothing or a single element (which we will call the head) and another linked
list as tail (which can be again one of the two). In C# we might write:
</p>

{% call macros.code("csharp", source=Msrc) %}
public abstract class SList<T>
{
}

public class Empty<T> : SList<T>
{
}

public class Cons<T> : SList<T>
{
  public T Head { get; }
  public SList<T> Tail { get; }

  public Cons(T head, SList<T> tail)
  {
      this.Head = head;
      this.Tail = tail;
  }
}
{% endcall %}

A basic for loop over the list can be done as follows.

{% call macros.code("csharp", source=Dsrc) %}
public static void PrintAll<T>(this SList<T> list)
{
    for (var prev = list; prev is Cons<T> el; prev = el.Tail)
    {
        Console.WriteLine(el.Head.ToString());
    }
}
{% endcall %}
</p>

<h2>Basic list operation</h2>
To make our lives a bit more easier down the road, and to explore
defining our own list type, we will define the basic concat
operation, which simply concatenates two lists, as well as the zip operation,
which joins every element of two lists at the same index in a tuple. When the lists
are of different sizes the zip operations stops when the one of the lists is consumed.

{% call macros.code("csharp", source=Msrc) %}
public static SList<T> concat<T>(this SList<T> one, SList<T> two)
{
    // This is C# 8 syntax
    switch ((one, two))
    {
        case (Empty<T> _, _): return two;
        case (_, Empty<T> _): return one;
        default:
            var left = one as Cons<T>;
            return new Cons<T>(
              left.Head,
              left.Tail.concat(two));
    }
}

public static SList<(T1, T2)> zip<T1, T2>(this SList<T1> one, SList<T2> two)
{
    switch ((one, two))
    {
        case (Empty<T1> _, _): return new Empty<(T1, T2)>();
        case (_, Empty<T2> _): return new Empty<(T1, T2)>();
        default:
            var left = one as Cons<T1>;
            var right = two as Cons<T2>;
            return new Cons<(T1, T2)>((left.Head, right.Head), left.Tail.zip<T1, T2>(right.Tail));
    }
}
{% endcall %}

<h2>Implementing the good stuff</h2>
As we know by now, the really interesting stuff is yet to be implemented.
Let's start with all the specifications first, and then reason about their
semantic meaning.

{% call macros.code("csharp") %}
public static SList<TOut> fmap<TIn, TOut>(this SList<TIn> list, Func<TIn, TOut> func)
{
  // TODO
}

public static SList<TOut> ab<TIn, TOut>(this SList<Func<TIn, TOut>> list, SList<TIn> arg)
{
  // TODO
}

public static SList<TOut> bind<TIn, TOut>(this SList<TIn> list, Func<TIn, SList<TOut>> func)
{
  // TODO
}

public static SList<T> pureSList<T>(T el)
{
  // TODO
}
{% endcall %}

<h3>Fmap makes Functors</h3>
"To apply a function over this object", that is the what fmap does. For maybe
this could also mean silent rejection in the case of Nothing. With lists it is
not much different; after all, we cannot apply a function over an empty list. 
For the non empty list we simply apply the function over the head and then apply
fmap over the tail recursively to affect the all the elements in the list.

{% call macros.code("csharp", source=Msrc) %}
public static SList<TOut> fmap<TIn, TOut>(this SList<TIn> list, Func<TIn, TOut> func)
{
  switch (list)
  {
      case Empty<TIn> _: return new Empty<TOut>();
      case Cons<TIn> el: return new Cons<TOut>(
        func(el.Head),
        fmap(el.Tail, func));
      default: return null;
  }
}

// The very useful reflected version
public static SList<TOut> fmap<TIn, TOut>(this Func<TIn, TOut> func, SList<TIn> list)
  => list.fmap(func);
{% endcall %}

We can now execute basic functions over our lists analogous to a loop.

{% call macros.code("csharp", source=Dsrc) %}
public static SList<int> Double(SList<int> list)
{
  return list.fmap(x => x + 1);
}

// Even changing the list's containing type
public static SList<string> ToWord(SList<int> list)
{
  var words = new string[] {"one", "two", "three", "four"};
  return list.fmap(x => x >= 0 && x < words.Length ? words[x] : "unknown number");
}
{% endcall %}

<h3>Ab makes Applicatives</h3>
"To apply an argument wrapped in an object to an object containing a function." is the sentence
that one ought to remember when implementing the function that ensures 
membership of the applicative typeclass. Similar to fmap repetition is the
key, we simply apply the given list of arguments to every function in the main list:

{% call macros.code("csharp", source=Msrc) %}
public static SList<TOut> ab<TIn, TOut>(this SList<Func<TIn, TOut>> list, SList<TIn> arg)
    => list.zip(arg).fmap(t => t.Item1(t.Item2));
{% endcall %}

<h3>Bind and pure and ye shall be a monad</h3>
"To apply a function to an object except the function returns an instance
of that same object". Capturing in the workings of bind in that sentence highlights
its similarity to fmap, except where fmap packages the result back into a functor,
bind already gets a monad back from its provided function. For the maybe monad this
was the end of the story, for lists we have a bit more complicated story. If we
extrapolate the concept of applying the operation to every element in the list we
end up with a list of lists. This would violate the definition of bind since its
resulting type is not the same as that of the given function. To settle this discrepancy
one can employ the help of concat to flatten the list of lists to a normal list again.
Consider the following steps:

{% call macros.code("haskell") %}
-- Function that returns a list with two copies of the argument
1. f = x => [x,x]
-- The input list l1
2. l1 = [1,2,3] 
-- Mapping f over l1 to get l2
3. l2 = [[1,1],[2,2],[3,3]]
-- Concatenating l2 to get l3
4. l3 = [1,1,2,2,3,3]
{% endcall %}

<p>
I hear you pondering and yes you are absolutely correct: bind for lists is the
same as concatenating after mapping, an operation also known as concatMap!
</p>

<p>
Us rests one final task before we may call SList a monad and that is to implement
pure. To complete our set of mnemonics: "To put an item inside an object". For lists
we could easily think to create a list with one item, a.k.a. a singleton. But we will
instead set out to derive this nonetheless correct idea from the holy <i>Monad Laws</i>.
We haven't touched on this before but there are 3 laws monads have to abide by regarding the
implementation of bind and pure. We will now only focus on 1, namely right identity:
</p>

{% call macros.code("haskell") %}
1. Left Identity:   (pure a)     >>= f        = f a
2. Right Identity:   m           >>= pure     = m
3. Associativity:   (m >>= f)    >>= g        = m >>= (\x -> f x >>= g)
{% endcall %}

What right identity tells is that the result of binding the pure function yield
is identical to the input (such a function is known as an identity function). To return
to the world of C# the following should hold:

{% call macros.code("csharp", source=Dsrc) %}
public static void CheckRightAssociativity()
{
  var input = new Cons<int>(
    1, new Cons<int>(
      2, new Cons<int>(
        3, new Empty<int>())));
  var output = input.bind(x => x.pureSList());
  Debug.Assert(input == output);
}
{% endcall %}

If we write down the steps we can derive what the pure function should yield:

{% call macros.code("haskell") %}
-- Input list
1. [1, 2, ..., n]
-- Apply the unknown function
2. [p(1), p(2), ..., p(n)]
-- Concatenating the result should yield
3. [1, 2, ..., n]
-- Reversing concatenation from 3 to 2 we find (among other possibilities)
4. [p(1), p(2), ..., p(n)] == [[1], [2], ..., [n]]
-- From that follows
5. forall x -> p(x) = [x]
{% endcall %}

So now the rather trivial implementation is the only thing that awaits us:

{% call macros.code("csharp", source=Msrc) %}
public static SList<T> pureSList<T>(this T item)
{
  return new Cons<T>(item, new Empty<T>());
}
{% endcall %}

<h2>Yielding the power</h2>
If you got to this part you may congratulate yourself, it is quite a pill to swallow.
In fact, lets celebrate our accomplishments by writing some useful transformations in
terms of our powerful set of functions. First of all, let's write filter in terms of bind.

{% call macros.code("csharp", source=Dsrc) %}
public static SList<T> filter<T>(this SList<T> list, Func<T, bool> predicate)
    => list.bind(x => predicate(x) ? x.pureSList() : new Empty<T>());
{% endcall %}

Also very interesting is the ease with which we can compute the Cartesian product
of two list:

{% call macros.code("csharp", source=Dsrc) %}
public static SList<(T,T)> cartesianProduct<T>(SList<T> one, SList<T> two)
{
    return one.bind(x => 
      two.bind(y => 
        new Cons<(T, T)>((x, y), new Empty<(T, T)>())));
}
{% endcall %}

And while the syntax of both the application and its use may not be very appealing,
I also present the list comprehension:

{% call macros.code("csharp", source=Dsrc) %}
public static SList<TOut> listComprension<TIn, TOut>(
  this SList<TIn> list,
  Func<TIn, TOut> mapping,
  Func<TIn, bool> predicate)
    => list.bind(x =>
    {
        if (predicate(x))
            return new Cons<TOut>(
              mapping(x),
              new Empty<TOut>()) as SList<TOut>;
        return new Empty<TOut>();
    });
{% endcall %}

And to not forget the usefulness of fmap and ab for composition:

{% call macros.code("csharp") %}
public static SList<int> sumLists(SList<int> one, SList<int> two)
{
    Func<int, Func<int, int>> sumFunc = a => b => a + b;
    return sumFunc.fmap(one).ab(two);
}
{% endcall %}


<h2>Summary</h2>
We have constructed the singly linked list in C# and made it no less than a Functor,
Applicative, and a Monad. We did this using some newly established mnemonics:

<ul>
  <li>fmap applies a given function to the contents of an object</li>
  <li>ab applies a given argument (wrapped in an object) to a function inside another object</li>
  <li>bind transforms the object by feeding its content to the given function</li>
  <li>pure wraps a regular value inside an object (whilst adhering to the 3 monad laws)</li>
</ul>

Finally we have shortly seen how these functions can be utilized and combined to implement
more complicated functions in an intuitive, bug resistant manner.

{% endblock %}
